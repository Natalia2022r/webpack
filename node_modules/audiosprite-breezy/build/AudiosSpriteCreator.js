"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const consts_1 = __importDefault(require("./consts"));
const path_1 = __importDefault(require("path"));
const fs_1 = __importDefault(require("fs"));
const mkdirp_1 = __importDefault(require("mkdirp"));
const child_process_1 = require("child_process");
const os_1 = __importDefault(require("os"));
const utils_1 = require("./utils");
class AudiosSpriteCreator {
    constructor(paths, options) {
        this.files = [...paths];
        this.options = Object.assign(Object.assign({}, consts_1.default), options);
        this.rootTemp = this.makeTemp();
        this.formats = (0, utils_1.getExportFormatsOptions)(this.options);
        this.offsetCursor = 0;
        this.json = {
            resources: [],
            spritemap: {},
        };
    }
    get wavArgs() {
        return ['-ar', `${this.options.samplerate}`, '-ac', `${this.options.channels}`, '-f', 's16le'];
    }
    checkFiles() {
        if (!this.files.length)
            return Promise.reject('No input files specified');
        return Promise.resolve();
    }
    createOutputDir() {
        const outputDir = path_1.default.dirname(this.options.output);
        return new Promise((resolve) => {
            fs_1.default.stat(outputDir, (error) => {
                if (error)
                    mkdirp_1.default.sync(outputDir);
                resolve();
            });
        });
    }
    spawn(name, options) {
        const { debug } = this.options.logger;
        debug('Spawn', { cmd: [name, ...options].join(' ') });
        return (0, child_process_1.spawn)(name, options);
    }
    checkFFMpeg() {
        return new Promise((resolve, reject) => {
            this.spawn('ffmpeg', ['-version'])
                .on('exit', (code) => {
                if (code)
                    reject('ffmpeg was not found on your path');
                else
                    resolve();
            });
        });
    }
    makeTemp(prefix = 'audiosprite') {
        const tmpdir = os_1.default.tmpdir() || '.';
        const file = path_1.default.join(tmpdir, `${prefix}.${Math.random().toString().substring(2)}`);
        this.options.logger.debug('Created temporary file', { file });
        return file;
    }
    appendSilence(duration = this.options.silence + this.options.gap, tempFile = this.rootTemp) {
        const { samplerate, channels, logger } = this.options;
        const buffer = Buffer.alloc(Math.round(samplerate * 2 * channels * duration));
        buffer.fill(0);
        const writeStream = fs_1.default.createWriteStream(tempFile, { flags: 'a' });
        writeStream.end(buffer);
        return new Promise((resolve) => {
            writeStream.on('close', () => {
                logger.info('Silence gap added', { duration });
                this.offsetCursor += duration;
                resolve();
            });
        });
    }
    prepare() {
        const { silence, autoplay } = this.options;
        if (!silence)
            return Promise.resolve();
        this.json.spritemap.silence = {
            start: 0,
            end: this.options.silence,
            loop: true,
        };
        if (!autoplay)
            this.json.autoplay = 'silence';
        return this.appendSilence();
    }
    makeRawAudioFile(src) {
        const dest = this.makeTemp();
        this.options.logger.debug('Start processing', { file: src });
        const isExists = fs_1.default.existsSync(src);
        if (!isExists)
            return Promise.reject(`File does not exist: ${src}`);
        const ffmpeg = this.spawn('ffmpeg', ['-i', path_1.default.resolve(src), ...this.wavArgs, 'pipe:']);
        const writeStream = fs_1.default.createWriteStream(dest, { flags: 'w' });
        ffmpeg.stdout.pipe(writeStream);
        return Promise.all([
            new Promise((resolve) => { writeStream.on('close', resolve); }),
            new Promise((resolve, reject) => {
                ffmpeg.on('close', (retcode, signal) => {
                    if (retcode) {
                        reject({
                            msg: 'File could not be added', file: src, retcode, signal,
                        });
                    }
                    else
                        resolve();
                });
            }),
        ])
            .then(() => Promise.resolve(dest));
    }
    appendFile(file, src) {
        const name = path_1.default.basename(file).replace(/\.[a-zA-Z0-9]+$/, '');
        const { autoplay, loop, samplerate, channels, minlength, } = this.options;
        let size = 0;
        const reader = fs_1.default.createReadStream(src);
        const writer = fs_1.default.createWriteStream(this.rootTemp, { flags: 'a' });
        reader.on('data', (data) => {
            size += data.length;
        });
        reader.pipe(writer);
        return new Promise((resolve) => {
            reader.on('close', () => {
                const originalDuration = size / (samplerate * channels * 2);
                this.options.logger.info('File added OK', { file: src, duration: originalDuration });
                let extraDuration = Math.max(0, minlength - originalDuration);
                const duration = originalDuration + extraDuration;
                this.json.spritemap[name] = {
                    start: this.offsetCursor,
                    end: this.offsetCursor + duration,
                    loop: name === autoplay || loop.includes(name),
                };
                this.offsetCursor += originalDuration;
                let delta = Math.ceil(duration) - duration;
                if (this.options.ignorerounding) {
                    this.options.logger.info('Ignoring nearest second silence gap rounding');
                    extraDuration = 0;
                    delta = 0;
                }
                this.appendSilence(extraDuration + delta + this.options.gap, this.rootTemp)
                    .then(() => resolve(src));
            });
        });
    }
    exportFileCaf(src, dest) {
        if (process.platform !== 'darwin')
            return Promise.resolve();
        return new Promise((resolve, reject) => {
            (0, child_process_1.spawn)('afconvert', ['-f', 'caff', '-d', 'ima4', src, dest])
                .on('exit', (code, signal) => {
                if (code) {
                    reject({
                        msg: 'Error exporting file',
                        format: 'caf',
                        retcode: code,
                        signal,
                    });
                    return;
                }
                this.options.logger.info('Exported caf OK', { file: dest });
                resolve();
            });
        });
    }
    exportFile(src, dest, ext, opt, store) {
        const outfile = `${dest}.${ext}`;
        return new Promise((resolve, reject) => {
            this.spawn('ffmpeg', ['-y', ...this.wavArgs, '-i', src, ...opt, outfile])
                .on('exit', (code, signal) => {
                if (code) {
                    reject({
                        msg: 'Error exporting file',
                        format: ext,
                        retcode: code,
                        signal,
                    });
                    return;
                }
                if (ext === 'aiff') {
                    this.exportFileCaf(outfile, `${dest}.caf`)
                        .then(() => {
                        if (store)
                            this.json.resources.push(`${dest}.caf`);
                        fs_1.default.unlinkSync(outfile);
                        resolve();
                    }, reject);
                }
                else {
                    this.options.logger.info(`Exported ${ext} OK`, { file: outfile });
                    if (store)
                        this.json.resources.push(outfile);
                    resolve();
                }
            });
        });
    }
    exportRawFiles(temp, index) {
        const exportPath = `${this.options.output}_${index}`;
        return (0, utils_1.getPromisesChain)(...this.options.rawparts
            .map((ext) => (() => this.exportFile(temp, exportPath, ext, (0, utils_1.getChosenAudioOptions)(this.options, ext), false))))
            .then(() => {
            fs_1.default.unlinkSync(temp);
            return Promise.resolve();
        });
    }
    processFile(file, index) {
        return this.makeRawAudioFile(file)
            .then((temp) => this.appendFile(file, temp))
            .then((temp) => this.exportRawFiles(temp, index));
    }
    processFiles() {
        const promiseFunctions = this.files.map((file, index) => (() => this.processFile(file, index)));
        return (0, utils_1.getPromisesChain)(...promiseFunctions);
    }
    exportFiles() {
        const promiseFunctions = Object.keys(this.formats)
            .map((key) => (() => this.exportFile(this.rootTemp, this.options.output, key, this.formats[key] || [], true)));
        return (0, utils_1.getPromisesChain)(...promiseFunctions);
    }
    exportJson() {
        fs_1.default.unlinkSync(this.rootTemp);
        if (this.options.autoplay)
            this.json.autoplay = this.options.autoplay;
        this.json.resources = this.json.resources
            .map((e) => (this.options.path ? path_1.default.join(this.options.path, path_1.default.basename(e)) : e));
        const { format } = this.options;
        if (format === 'createjs') {
            const audioSprite = [];
            Object.keys(this.json.spritemap).forEach((key) => {
                const spriteInfo = this.json.spritemap[key];
                const audiospriteInstance = {
                    id: key,
                    startTime: spriteInfo.start * 1000,
                    duration: (spriteInfo.end - spriteInfo.start) * 1000,
                };
                audioSprite.push(audiospriteInstance);
            });
            const output = { src: this.json.resources[0], data: { audioSprite } };
            return Promise.resolve(output);
        }
        const sprite = {};
        Object.keys(this.json.spritemap).forEach((key) => {
            const spriteInfo = this.json.spritemap[key];
            sprite[key] = [
                spriteInfo.start * 1000,
                (spriteInfo.end - spriteInfo.start) * 1000,
            ];
            if (spriteInfo.loop)
                sprite[key].push(true);
        });
        if (format === 'howler') {
            const output = { sprite, urls: this.json.resources };
            return Promise.resolve(output);
        }
        if (format === 'howler2') {
            const output = { sprite, src: this.json.resources };
            return Promise.resolve(output);
        }
        return Promise.resolve(this.json);
    }
}
exports.default = AudiosSpriteCreator;
